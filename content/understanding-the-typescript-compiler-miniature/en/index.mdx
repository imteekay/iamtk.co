<SmoothRender>

As you may know, I've been studying compilers. A lot. For the past month, I've been learning more about the TypeScript compiler, reading its source code, and implementing some of the exercises from the [mini-typescript](https://github.com/imteekay/mini-typescript).

In this post, I want to cover some of my learnings while reading the TypeScript compiler miniature's source code and implementing the exercises.

I divided this series into three parts and the following posts to cover everything about the TypeScript compiler. The first two are already published and you can take a look at them here:

- [A High Level Architecture of the TypeScript compiler](https://www.iamtk.co/a-high-level-architecture-of-the-typescript-compiler)
- [JavaScript scope, Closures, and the TypeScript compiler](https://iamtk.co/javascript-scope-closures-and-the-typescript-compiler)

And now, in this post, I will cover different features of the [mini-typescript](https://github.com/imteekay/mini-typescript) and how they are implemented. For the exercises I implemented in the project, I will write new articles in the following posts of the series.

By the way, I think it's a good idea to read the first two posts before reading this if you don't know how compilers work and how the TypeScript compiler works. The first one will give a good overview of the steps of the compiler and how each piece fits together. The second one will talk about closures and how they are used to make the compiler more modular and easier to change.

With the two pieces, I think you'll be ready to read how some of the features of the TypeScript miniature are implemented.

Let's go!

---

Before going into each feature, I just want to illustrate how the compiler structures each step. Basically, how it represents tokens in the lexer step, AST nodes in the parser, variable and type declarations in the binder, and types in the type checker.

## Representing tokens

The idea of a lexer is to go through character by character and produce a new token. It receives the source code as a string and starts from position `0`. In this simplest version, it has states like `pos` as the position of the current character it's analyzing, `token` as the token type of the produced token, and `text` that could be the name of an identifier (e.g. `age` from `var age = 1;`), a number value (e.g. `1`), a keyword (e.g. `var`), or a string value (e.g. `"string"`).

As an example, if we have this source code

```jsx
var age = 1;
```

The lexer will produce this list of tokens

- `var`:
  - `text`: “var”
  - `token`: “Var”
- `age`:
  - `text`: “age”
  - `token`: “Identifier”
- `=`:
  - `text`: undefined
  - `token`: “Equals”
- `1`:
  - `text`: “1”
  - `token`: “NumericLiteral”

In a visible way, it should look like this

[Add illustration: from source code to tokens using this example above]

## Representing AST nodes

## Resources

- [TypeScript codebase](https://github.com/microsoft/typescript?utm_source=iamtk.co&utm_medium=referral&utm_campaign=tk_newsletter)
- [How the TypeScript Compiler Compiles](https://www.youtube.com/watch?v=X8k_4tZ16qU&utm_source=iamtk.co&utm_medium=referral&utm_campaign=tk_newsletter)
- [mini-typescript](https://github.com/imteekay/mini-typescript)
- [TypeScript Compiler Manual](https://sandersn.github.io/manual/Typescript-compiler-implementation.html?utm_source=iamtk.co&utm_medium=referral&utm_campaign=tk_newsletter)

---

</SmoothRender>
