<SmoothRender>

Depois de muito tempo aprendendo e trabalhando com programa√ß√£o orientada a objetos, dei um passo atr√°s para pensar sobre a complexidade de sistemas.

> ‚ÄúComplexidade √© qualquer coisa que torna o software dif√≠cil de entender ou modificar.‚Äù‚Ää‚Äî‚ÄäJohn Outerhout

Fazendo algumas pesquisas, encontrei conceitos de programa√ß√£o funcional como imutabilidade e fun√ß√£o pura. Esses conceitos s√£o grandes vantagens para criar fun√ß√µes sem efeitos colaterais, por isso √© mais f√°cil manter sistemas‚Ää‚Äî‚Ääcom alguns outros [benef√≠cios](https://hackernoon.com/why-functional-programming-matters-c647f56a7691).

Neste post, falarei mais sobre programa√ß√£o funcional e alguns conceitos importantes, com muitos exemplos de c√≥digo. Em JavaScript!

### O que √© programa√ß√£o funcional?

> Programa√ß√£o funcional √© um paradigma de programa√ß√£o‚Ää‚Äî‚Ääum estilo de constru√ß√£o da estrutura e elementos de programas de computador‚Ää‚Äî‚Ääque trata a computa√ß√£o como a avalia√ß√£o de fun√ß√µes matem√°ticas e evita dados mut√°veis ‚Äã‚Äãe de estado de mudan√ßa‚Ää‚Äî‚ÄäWikipedia

### Fun√ß√µes puras

![](https://cdn-images-1.medium.com/max/1600/0*FMur6URY7yAVjeuP)

O primeiro conceito fundamental que aprendemos quando queremos entender a programa√ß√£o funcional √© **fun√ß√µes puras**. Mas o que isso realmente significa? O que torna uma fun√ß√£o pura?

Ent√£o, como sabemos se uma fun√ß√£o √© 'pura' ou n√£o? Aqui est√° uma defini√ß√£o muito estrita de pureza:

- Retorna o mesmo resultado se receber os mesmos argumentos (tamb√©m √© referido como `determin√≠stico`)
- N√£o causa efeitos colaterais observ√°veis

#### Retorna o mesmo resultado se receber os mesmos argumentos

Imagine que queremos implementar uma fun√ß√£o que calcula a √°rea de um c√≠rculo. Uma fun√ß√£o impura receberia `radius` como par√¢metro e ent√£o calcularia `radius * radius * PI`:

```javascript
const PI = 3.14;

function calculateArea(radius) {
  return radius * radius * PI;
}

calculateArea(10); // returns 314.0
```

Por que esta √© uma fun√ß√£o impura? Simplesmente porque usa um objeto global que n√£o foi passado como par√¢metro para a fun√ß√£o.

Agora imagine que alguns matem√°ticos argumentam que o valor `PI` √© na verdade `42` e alteram o valor do objeto global.

Nossa fun√ß√£o impura agora resultar√° em `10 * 10 * 42` = `4200`. Para o mesmo par√¢metro (`radius = 10`), temos um resultado diferente. Vamos corrigi-lo!

```javascript
const PI = 3.14;

function calculateArea(radius, pi) {
  return radius * radius * pi;
}

calculateArea(10, PI); // returns 314.0
```

TA-DA üéâ! Agora sempre passaremos o valor `PI` como par√¢metro para a fun√ß√£o. Ent√£o agora estamos apenas acessando os par√¢metros passados para a fun√ß√£o. Nenhum `objeto externo`.

- Para os par√¢metros `radius = 10` & `PI = 3.14`, teremos sempre o mesmo resultado: `314.0`
- Para os par√¢metros `radius = 10` & `PI = 42`, teremos sempre o mesmo resultado: `4200`

#### Lendo arquivos

Se nossa fun√ß√£o l√™ arquivos externos, n√£o √© uma fun√ß√£o pura‚Ää‚Äî‚Ääo conte√∫do do arquivo pode mudar.

```javascript
function charactersCounter(text) {
  return `Character count: ${text.length}`;
}

function analyzeFile(filename) {
  let fileContent = open(filename);
  return charactersCounter(fileContent);
}
```

#### Gera√ß√£o de n√∫meros aleat√≥rios

Qualquer fun√ß√£o que dependa de um gerador de n√∫meros aleat√≥rios n√£o pode ser pura.

```javascript
function yearEndEvaluation() {
  if (Math.random() > 0.5) {
    return 'You get a raise!';
  } else {
    return 'Better luck next year!';
  }
}
```

#### N√£o causa efeitos colaterais observ√°veis

Exemplos de efeitos colaterais observ√°veis incluem modificar um objeto global ou um par√¢metro passado por refer√™ncia.

Agora queremos implementar uma fun√ß√£o para receber um valor inteiro e retornar o valor aumentado em 1.

```javascript
let counter = 1;

function increaseCounter(value) {
  counter = value + 1;
}

increaseCounter(counter);
console.log(counter); // 2
```

Temos o valor `counter`. Nossa fun√ß√£o impura recebe esse valor e reatribui o contador com o valor aumentado em 1.

**Observa√ß√£o**: a mutabilidade √© desencorajada na programa√ß√£o funcional.

Estamos modificando o objeto global. Mas como poder√≠amos torn√°-lo 'puro'? Basta retornar o valor aumentado em 1. Simples assim.

```javascript
let counter = 1;

function increaseCounter(value) {
  return value + 1;
}

increaseCounter(counter); // 2
console.log(counter); // 1
```

Veja que nossa fun√ß√£o pura `increaseCounter` retorna 2, mas o valor `counter` ainda √© o mesmo. A fun√ß√£o retorna o valor incrementado sem alterar o valor da vari√°vel.

Se seguirmos essas duas regras simples, fica mais f√°cil entender nossos programas. Agora todas as fun√ß√µes est√£o isoladas e incapazes de impactar outras partes do nosso sistema.

Fun√ß√µes puras s√£o est√°veis, consistentes e previs√≠veis. Dados os mesmos par√¢metros, fun√ß√µes puras sempre retornar√£o o mesmo resultado. N√£o precisamos pensar em situa√ß√µes em que o mesmo par√¢metro tem resultados diferentes‚Ää‚Äî‚Ääporque isso nunca acontecer√°.

#### Benef√≠cios das fun√ß√µes puras

O c√≥digo √© definitivamente mais f√°cil de testar. N√£o precisamos zombar de nada. Assim, podemos testar fun√ß√µes puras de unidade com diferentes contextos:

- Dado um par√¢metro `A` ‚Üí espere que a fun√ß√£o retorne o valor `B`
- Dado um par√¢metro `C` ‚Üí espere que a fun√ß√£o retorne o valor `D`

Um exemplo simples seria uma fun√ß√£o receber uma cole√ß√£o de n√∫meros e esperar que ela incremente cada elemento dessa cole√ß√£o.

```javascript
let list = [1, 2, 3, 4, 5];

function incrementNumbers(list) {
  return list.map((number) => number + 1);
}
```

Recebemos o array `numbers`, usamos `map` incrementando cada n√∫mero e retornamos uma nova lista de n√∫meros incrementados.

```javascript
incrementNumbers(list); // [2, 3, 4, 5, 6]
```

Para a `entrada` `[1, 2, 3, 4, 5]`, a `sa√≠da` esperada seria `[2, 3, 4, 5, 6]`.

### Imutabilidade

> Inalter√°vel ao longo do tempo ou imposs√≠vel de ser alterado.

![](https://cdn-images-1.medium.com/max/1600/0*MGlzHgISuw0dXwsf)

Quando os dados s√£o imut√°veis, seu estado n√£o pode ser alterado ap√≥s sua cria√ß√£o. Se voc√™ deseja alterar um objeto imut√°vel, n√£o pode. Em vez disso, **voc√™ cria um novo objeto com o novo valor.**

Em JavaScript geralmente usamos o loop `for`. Esta pr√≥xima instru√ß√£o `for` tem algumas vari√°veis mut√°veis.

```javascript
var values = [1, 2, 3, 4, 5];
var sumOfValues = 0;

for (var i = 0; i < values.length; i++) {
  sumOfValues += values[i];
}

sumOfValues; // 15
```

Para cada itera√ß√£o, estamos alterando o `i` e o **estado** `sumOfValue`. Mas como lidamos com a mutabilidade na itera√ß√£o? Recurs√£o!

```javascript
let list = [1, 2, 3, 4, 5];
let accumulator = 0;

function sum(list, accumulator) {
  if (list.length == 0) {
    return accumulator;
  }

  return sum(list.slice(1), accumulator + list[0]);
}

sum(list, accumulator); // 15
list; // [1, 2, 3, 4, 5]
accumulator; // 0
```

Ent√£o aqui temos a fun√ß√£o `sum` que recebe um vetor de valores num√©ricos. A fun√ß√£o chama a si mesma at√© que a lista fique vazia ([nossa recurs√£o](<https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursive_functions_and_algorithms>) `base case`). Para cada "itera√ß√£o" adicionaremos o valor ao acumulador `total`.

Com a recurs√£o, mantemos nossas vari√°veis imut√°veis. As vari√°veis `list` e `accumulator` n√£o s√£o alteradas. Mant√©m o mesmo valor.

**Observa√ß√£o**: Sim! Podemos usar `reduce` para implementar esta fun√ß√£o. Abordaremos isso no t√≥pico `Fun√ß√µes de ordem superior`.

Tamb√©m √© muito comum construir o **estado** final de um objeto. Imagine que temos uma string e queremos transformar essa string em um `url slug`.

Em OOP em Ruby, criar√≠amos uma classe, digamos, `UrlSlugify`. E esta classe ter√° um m√©todo `slugify!` para transformar a string de entrada em um `url slug`.

```ruby
class UrlSlugify
  attr_reader :text

  def initialize(text)
    @text = text
  end

  def slugify!
    text.downcase!
    text.strip!
    text.gsub!(' ', '-')
  end
end

UrlSlugify.new(' I will be a url slug   ').slugify! # "i-will-be-a-url-slug"
```

Lindo! Est√° implementado! Aqui temos uma programa√ß√£o imperativa dizendo exatamente o que queremos fazer em cada processo `slugify`‚Ää‚Äî‚Ääprimeira letra min√∫scula, depois remova os espa√ßos em branco in√∫teis e, finalmente, substitua os espa√ßos em branco restantes por h√≠fens.

Mas estamos mudando o estado de entrada neste processo.

Podemos lidar com essa muta√ß√£o fazendo composi√ß√£o de fun√ß√µes ou encadeamento de fun√ß√µes. Em outras palavras, o resultado de uma fun√ß√£o ser√° usado como entrada para a pr√≥xima fun√ß√£o, sem modificar a string de entrada original.

```javascript
let string = ' I will be a url slug   ';

function slugify(string) {
  return string.toLowerCase().trim().split(' ').join('-');
}

slugify(string); // i-will-be-a-url-slug
```

Aqui temos:

- `toLowerCase`: converte a string para todas as letras min√∫sculas
- `trim`: remove espa√ßos em branco de ambas as extremidades de uma string
- `split` e `join`: substitui todas as inst√¢ncias de correspond√™ncia por substitui√ß√£o em uma determinada string

Combinamos todas essas 4 fun√ß√µes e podemos `"slugify"` nossa string.

### Transpar√™ncia referencial

![](https://cdn-images-1.medium.com/max/1600/0*K0VAbQjAwmKZb1at)

Vamos implementar uma `fun√ß√£o square`:

```javascript
function square(n) {
  return n * n;
}
```

Esta fun√ß√£o pura sempre ter√° a mesma sa√≠da, dada a mesma entrada.

```javascript
square(2); // 4
square(2); // 4
square(2); // 4
// ...
```

Passar `2` como par√¢metro da `fun√ß√£o square` sempre retornar√° 4. Ent√£o agora podemos substituir `square(2)` por 4. Pronto! Nossa fun√ß√£o √© `referencialmente transparente`.

Basicamente, se uma fun√ß√£o produz consistentemente o mesmo resultado para a mesma entrada, ela √© referencialmente transparente.

**fun√ß√µes puras + dados imut√°veis = transpar√™ncia referencial**

Com esse conceito, uma coisa legal que podemos fazer √© memorizar a fun√ß√£o. Imagine que temos esta fun√ß√£o:

```javascript
function sum(a, b) {
  return a + b;
}
```

E n√≥s o chamamos com estes par√¢metros:

```javascript
sum(3, sum(5, 8));
```

A `sum(5, 8)` √© igual a `13`. Esta fun√ß√£o sempre resultar√° em `13`. Ent√£o podemos fazer isso:

```javascript
sum(3, 13);
```

E esta express√£o sempre resultar√° em `16`. Podemos substituir a express√£o inteira por uma constante num√©rica e [memoize](/pt-BR/writing-a-memoization-function-from-scratch).

### Fun√ß√µes como entidades de primeira classe

![](https://cdn-images-1.medium.com/max/1600/0*K6m1Ftw54Wm6tfFB)

A ideia de fun√ß√µes como entidades de primeira classe √© que fun√ß√µes **tamb√©m** s√£o tratadas como valores **e** usadas como dados.

Fun√ß√µes como entidades de primeira classe podem:

- consulte-o a partir de constantes e vari√°veis
- pass√°-lo como par√¢metro para outras fun√ß√µes
- devolv√™-lo como resultado de outras fun√ß√µes

A ideia √© tratar fun√ß√µes como valores e passar fun√ß√µes como dados. Desta forma podemos combinar diferentes fun√ß√µes para criar novas fun√ß√µes com novo comportamento.

Imagine que temos uma fun√ß√£o que soma dois valores e depois dobra o valor. Algo assim:

```javascript
function doubleSum(a, b) {
  return (a + b) * 2;
}
```

Agora uma fun√ß√£o que subtrai valores e retorna o dobro:

```javascript
function doubleSubtraction(a, b) {
  return (a - b) * 2;
}
```

Essas fun√ß√µes t√™m l√≥gica semelhante, mas a diferen√ßa s√£o as fun√ß√µes dos operadores. Se pudermos tratar fun√ß√µes como valores e pass√°-los como argumentos, podemos construir uma fun√ß√£o que receba a fun√ß√£o do operador e use-a dentro de nossa fun√ß√£o. Vamos constru√≠-lo!

```javascript
function sum(a, b) {
  return a + b;
}

function subtraction(a, b) {
  return a - b;
}

function doubleOperator(f, a, b) {
  return f(a, b) * 2;
}

doubleOperator(sum, 3, 1); // 8
doubleOperator(subtraction, 3, 1); // 4
```

Feito! Agora temos um argumento `f` e o usamos para processar `a` e `b`. Passamos as fun√ß√µes `sum` e `subtraction` para compor com a fun√ß√£o `doubleOperator` e criar um novo comportamento.

### Fun√ß√µes de ordem superior

Quando falamos de fun√ß√µes de ordem superior, queremos dizer uma fun√ß√£o que:

- recebe uma ou mais fun√ß√µes como argumentos, ou

- retorna uma fun√ß√£o como seu resultado

A fun√ß√£o `doubleOperator` que implementamos acima √© uma fun√ß√£o de ordem superior porque recebe uma fun√ß√£o de operador como argumento e a usa.

Voc√™ provavelmente j√° ouviu falar sobre `filter`, `map` e `reduce`. Vamos dar uma olhada nestes.

### Filtro

Dada uma cole√ß√£o, queremos filtrar por um atributo. A fun√ß√£o de filtro espera um valor `true` ou `false` para determinar se o elemento **deve ou n√£o** ser inclu√≠do na cole√ß√£o de resultados. Basicamente, se a express√£o de retorno de chamada for `true`, a fun√ß√£o de filtro incluir√° o elemento na cole√ß√£o de resultados. Caso contr√°rio, n√£o.

Um exemplo simples √© quando temos uma cole√ß√£o de inteiros e queremos apenas os n√∫meros pares.

**Abordagem imperativa**

Uma maneira imperativa de fazer isso com JavaScript √©:

- crie um array vazio `evenNumbers`

- iterar sobre o array `numbers`

- empurre os n√∫meros pares para o array `evenNumbers`

```javascript
var numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var evenNumbers = [];

for (var i = 0; i < numbers.length; i++) {
  if (numbers[i] % 2 == 0) {
    evenNumbers.push(numbers[i]);
  }
}

console.log(evenNumbers); // (6)¬†[0, 2, 4, 6, 8, 10]
```

Tamb√©m podemos usar a fun√ß√£o de ordem superior `filter` para receber a fun√ß√£o `even` e retornar uma lista de n√∫meros pares:

```javascript
function even(number) {
  return number % 2 == 0;
}

let listOfNumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
listOfNumbers.filter(even); // [0, 2, 4, 6, 8, 10]
```

Um problema interessante que resolvi no caminho [Hacker Rank FP](https://www.hackerrank.com/domains/fp) foi o [Problema da matriz de filtros](https://www.hackerrank.com/challenges/fp-filter-array/problem). A ideia do problema √© filtrar um determinado array de inteiros e produzir apenas os valores que s√£o menores que um valor especificado `X`.

Uma solu√ß√£o JavaScript imperativa para este problema √© algo como:

```javascript
var filterArray = function (x, coll) {
  var resultArray = [];

  for (var i = 0; i < coll.length; i++) {
    if (coll[i] < x) {
      resultArray.push(coll[i]);
    }
  }

  return resultArray;
};

console.log(filterArray(3, [10, 9, 8, 2, 7, 5, 1, 3, 0])); // (3)¬†[2, 1, 0]
```

We say exactly what our function needs to do‚Ää‚Äî‚Ääiterate over the collection, compare the collection current item with `x`, and push this element to the `resultArray` if it pass the condition.

**Declarative approach**

But we want a more declarative way to solve this problem, and using the `filter` higher order function as well.

A declarative JavaScript solution would be something like this:

```javascript
function smaller(number) {
  return number < this;
}

function filterArray(x, listOfNumbers) {
  return listOfNumbers.filter(smaller, x);
}

let numbers = [10, 9, 8, 2, 7, 5, 1, 3, 0];

filterArray(3, numbers); // [2, 1, 0]
```

Usar `this` na fun√ß√£o `smaller` parece um pouco estranho em primeiro lugar, mas √© f√°cil de entender.

`this` ser√° o segundo par√¢metro na fun√ß√£o `filter`. Neste caso, `3` (o `x`) √© representado por `this`. √â isso.

Tamb√©m podemos fazer isso com mapas. Imagine que temos um map de pessoas com seus `name` e `age`.

```javascript
let people = [
  { name: 'TK', age: 26 },
  { name: 'Kaio', age: 10 },
  { name: 'Kazumi', age: 30 },
];
```

E queremos filtrar apenas pessoas acima de um determinado valor de idade, neste exemplo, pessoas com mais de 21 anos.

```javascript
function olderThan21(person) {
  return person.age > 21;
}

function overAge(people) {
  return people.filter(olderThan21);
}

overAge(people); // [{ name: 'TK', age: 26 }, { name: 'Kazumi', age: 30 }]
```

Resumo do c√≥digo:

- temos uma lista de pessoas (com `nome` e `idade`).
- temos uma fun√ß√£o `olderThan21`. Nesse caso, para cada pessoa no array people, queremos acessar a `idade` e ver se ela tem mais de 21 anos.
- filtramos todas as pessoas com base nesta fun√ß√£o.

### Map

A ideia do map √© transformar uma cole√ß√£o.

> O m√©todo map transforma uma cole√ß√£o aplicando uma fun√ß√£o a todos os seus elementos e criando uma nova cole√ß√£o a partir dos valores retornados.

Vamos pegar a mesma cole√ß√£o `people` acima. N√£o queremos filtrar por ‚Äúmais de idade‚Äù agora. Queremos apenas uma lista de strings, algo como `TK tem 26 anos`. Portanto, a string final pode ser¬†`:name is :age years old` onde¬†`:name` e¬†`:age` s√£o atributos de cada elemento na cole√ß√£o `people`.

De uma forma JavaScript imperativa, seria:

```javascript
var people = [
  { name: 'TK', age: 26 },
  { name: 'Kaio', age: 10 },
  { name: 'Kazumi', age: 30 },
];

var peopleSentences = [];

for (var i = 0; i < people.length; i++) {
  var sentence = people[i].name + ' is ' + people[i].age + ' years old';
  peopleSentences.push(sentence);
}

console.log(peopleSentences); // ['TK is 26 years old', 'Kaio is 10 years old', 'Kazumi is 30 years old']
```

De uma forma JavaScript declarativa, seria:

```javascript
function makeSentence(person) {
  return `${person.name} is ${person.age} years old`;
}

function peopleSentences(people) {
  return people.map(makeSentence);
}

peopleSentences(people); // ['TK is 26 years old', 'Kaio is 10 years old', 'Kazumi is 30 years old']
```

A ideia √© transformar um determinado array em um novo array.

Outro problema interessante do Hacker Rank foi o [update list problem](https://www.hackerrank.com/challenges/fp-update-list/problem). Queremos apenas atualizar os valores de um determinado array com seus valores absolutos.

Por exemplo, a entrada `[1, 2, 3, -4, 5]` precisa que a sa√≠da seja `[1, 2, 3, 4, 5]`. O valor absoluto de `-4` √© `4`.

Uma solu√ß√£o simples seria uma atualiza√ß√£o in-loco para cada valor de cole√ß√£o.

```javascript
var values = [1, 2, 3, -4, 5];

for (var i = 0; i < values.length; i++) {
  values[i] = Math.abs(values[i]);
}

console.log(values); // [1, 2, 3, 4, 5]
```

Usamos a fun√ß√£o `Math.abs` para transformar o valor em seu valor absoluto e fazemos a atualiza√ß√£o in-loco.

Esta **n√£o** √© uma forma funcional de implementar esta solu√ß√£o.

Primeiro, aprendemos sobre imutabilidade. Sabemos como a imutabilidade √© importante para tornar nossas fun√ß√µes mais consistentes e previs√≠veis. A ideia √© construir uma nova cole√ß√£o com todos os valores absolutos.

Segundo, por que n√£o usar `map` aqui para "transformar" todos os dados?

Minha primeira id√©ia foi testar a fun√ß√£o `Math.abs` para manipular apenas um valor.

```javascript
Math.abs(-1); // 1
Math.abs(1); // 1
Math.abs(-2); // 2
Math.abs(2); // 2
```

Queremos transformar cada valor em um valor positivo (o valor absoluto).

Agora que sabemos como fazer `absolute` para um valor, podemos usar esta fun√ß√£o para passar como argumento para a fun√ß√£o `map`. Voc√™ se lembra que uma 'fun√ß√£o de ordem superior' pode receber uma fun√ß√£o como argumento e us√°-la? Sim, o map pode faz√™-lo!

```javascript
let values = [1, 2, 3, -4, 5];

function updateListMap(values) {
  return values.map(Math.abs);
}

updateListMap(values); // [1, 2, 3, 4, 5]
```

Wow. So beautiful! üòç

### Reduce

The idea of reduce is to receive a function and a collection, and return a value created by combining the items.

A common example people talk about is to get the total amount of an order. Imagine you were at a shopping website. You‚Äôve added `Product 1`, `Product 2`, `Product 3`, and `Product 4` to your shopping cart (order). Now we want to calculate the total amount of the shopping cart.

In imperative way, we would iterate the order list and sum each product amount to the total amount.

```javascript
var orders = [
  { productTitle: 'Product 1', amount: 10 },
  { productTitle: 'Product 2', amount: 30 },
  { productTitle: 'Product 3', amount: 20 },
  { productTitle: 'Product 4', amount: 60 },
];

var totalAmount = 0;

for (var i = 0; i < orders.length; i++) {
  totalAmount += orders[i].amount;
}

console.log(totalAmount); // 120
```

Usando `reduce`, podemos construir uma fun√ß√£o para lidar com a `amount sum` e pass√°-la como um argumento para a fun√ß√£o `reduce`.

```javascript
let shoppingCart = [
  { productTitle: 'Product 1', amount: 10 },
  { productTitle: 'Product 2', amount: 30 },
  { productTitle: 'Product 3', amount: 20 },
  { productTitle: 'Product 4', amount: 60 },
];

const sumAmount = (currentTotalAmount, order) =>
  currentTotalAmount + order.amount;

function getTotalAmount(shoppingCart) {
  return shoppingCart.reduce(sumAmount, 0);
}

getTotalAmount(shoppingCart); // 120
```

Aqui temos `shoppingCart`, a fun√ß√£o `sumAmount` que recebe o `currentTotalAmount`¬†e o objeto `order` para `sum`.

A fun√ß√£o `getTotalAmount` √© usada para `reduzir` o `shoppingCart` usando `sumAmount` e come√ßando em `0`.

Outra maneira de obter o valor total √© compor `map` e `reduce`. O que quero dizer com isso? Podemos usar `map` para transformar o `shoppingCart` em uma cole√ß√£o de valores `amount`, e ent√£o usar a fun√ß√£o `reduce` com a fun√ß√£o `sumAmount`.

```javascript
const getAmount = (order) => order.amount;
const sumAmount = (acc, amount) => acc + amount;

function getTotalAmount(shoppingCart) {
  return shoppingCart.map(getAmount).reduce(sumAmount, 0);
}

getTotalAmount(shoppingCart); // 120
```

O `getAmount` recebe o objeto do produto e retorna apenas o valor `amount`. Ent√£o o que temos aqui √© `[10, 30, 20, 60]`. E ent√£o o `reduce` combina todos os itens somando. Lindo!

Demos uma olhada em como funciona cada fun√ß√£o de ordem superior. Quero mostrar um exemplo de como podemos compor as tr√™s fun√ß√µes em um exemplo simples.

Falando em `carrinho de compras`, imagine que temos esta lista de produtos em nosso pedido:

```javascript
let shoppingCart = [
  { productTitle: 'Functional Programming', type: 'books', amount: 10 },
  { productTitle: 'Kindle', type: 'eletronics', amount: 30 },
  { productTitle: 'Shoes', type: 'fashion', amount: 20 },
  { productTitle: 'Clean Code', type: 'books', amount: 60 },
];
```

Queremos a quantidade total de todos os livros em nosso carrinho de compras. Simples assim. O algoritmo?

- **filtro** por tipo de livro
- transforme o carrinho de compras em uma cole√ß√£o de valores usando o **map**
- combine todos os itens adicionando-os com **reduzir**

```javascript
let shoppingCart = [
  { productTitle: 'Functional Programming', type: 'books', amount: 10 },
  { productTitle: 'Kindle', type: 'eletronics', amount: 30 },
  { productTitle: 'Shoes', type: 'fashion', amount: 20 },
  { productTitle: 'Clean Code', type: 'books', amount: 60 },
];

const byBooks = (order) => order.type == 'books';
const getAmount = (order) => order.amount;
const sumAmount = (acc, amount) => acc + amount;

function getTotalAmount(shoppingCart) {
  return shoppingCart.filter(byBooks).map(getAmount).reduce(sumAmount, 0);
}

getTotalAmount(shoppingCart); // 70
```

Cab√¥! üéâ

### Recursos

Organizei alguns recursos que li e estudei. Estou compartilhando os que achei realmente interessantes. Para mais recursos, visite meu [Functional Programming Github repository](https://github.com/imteekay/functional-programming-learning-path).

- [EcmaScript 6 course by Wes Bos](https://ES6.io/friend/LEANDRO)
- [JavaScript specific resources](https://github.com/imteekay/functional-programming-learning-path/tree/master/javascript)
- [Clojure specific resources](https://github.com/imteekay/functional-programming-learning-path/tree/master/clojure)
- [Ruby specific resources](https://github.com/imteekay/functional-programming-learning-path/tree/master/ruby)

#### Intros

- [Learning FP in JS](https://www.youtube.com/watch?v=e-5obm1G_FY)
- [Intro do FP with Python](https://codewords.recurse.com/issues/one/an-introduction-to-functional-programming)
- [Overview of FP](https://blog.codeship.com/overview-of-functional-programming)
- [A quick intro to functional JS](https://hackernoon.com/a-quick-introduction-to-functional-javascript-7e6fe520e7fa)
- [What is FP?](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0)
- [Functional Programming Jargon](https://github.com/hemanth/functional-programming-jargon)

#### Pure functions

- [What is a pure function?](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976)
- [Pure Functional Programming 1](https://www.fpcomplete.com/blog/2017/04/pure-functional-programming)
- [Pure Functional Programming 2](https://www.fpcomplete.com/blog/2017/05/pure-functional-programming-part-2)

#### Immutable data

- [Immutable DS for functional programming](https://www.youtube.com/watch?v=Wo0qiGPSV-s)
- [Why shared mutable state is the root of all evil](http://henrikeichenhardt.blogspot.com/2013/06/why-shared-mutable-state-is-root-of-all.html)

#### Higher-order functions

- [Eloquent JS: Higher Order Functions](https://eloquentjavascript.net/05_higher_order.html)
- [Fun fun function Filter](https://www.youtube.com/watch?v=BMUiFMZr7vk&t=0s&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&index=2&ab_channel=FunFunFunction)
- [Fun fun function Map](https://www.youtube.com/watch?v=bCqtb-Z5YGQ&index=2&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&ab_channel=FunFunFunction)
- [Fun fun function Basic Reduce](https://www.youtube.com/watch?v=Wl98eZpkp-c&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&index=3&frags=wn&ab_channel=FunFunFunction)
- [Fun fun function Advanced Reduce](https://www.youtube.com/watch?v=1DMolJ2FrNY&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84&index=4&ab_channel=FunFunFunction)
- [Clojure Higher Order Functions](https://clojure.org/guides/higher_order_functions)
- [Purely Function Filter](https://purelyfunctional.tv/lesson/filter/)
- [Purely Functional Map](https://purelyfunctional.tv/lesson/map/)
- [Purely Functional Reduce](https://purelyfunctional.tv/lesson/reduce/)

#### Declarative Programming

- [Declarative Programming vs Imperative](https://tylermcginnis.com/imperative-vs-declarative-programming/)

## √â isso!

Oi pessoal, espero que tenham se divertido lendo esse post, e espero que tenham aprendido muito aqui! Essa foi minha tentativa de compartilhar o que estou aprendendo.

[Aqui est√° o reposit√≥rio com todos os c√≥digos](https://github.com/tk-notes/fp-in-javascript-article-source-code) deste artigo.

Venha aprender comigo. Estou compartilhando recursos e meu c√≥digo neste [reposit√≥rio de programa√ß√£o funcional de aprendizado](https://github.com/imteekay/functional-programming-learning-path).

Eu tamb√©m escrevi um [post FP, mas usando principalmente Clojure](/an-introduction-to-the-basic-principles-of-functional-programming).

Espero que tenha visto algo √∫til para voc√™ aqui. E at√© a pr√≥xima!

</SmoothRender>
